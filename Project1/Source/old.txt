unsigned int ind[] = {
        0, 1, 3, // first triangle
        1, 2, 3  // second triangle
    };

    float vert1[] = {
        // positions          // colors      
         0.0f, 0.0f, 0.0f,   0.7f, 0.0f, 0.0f,
         0.0f, 0.0f, 0.5f,   0.0f, 0.7f, 0.0f,
         0.5f, 0.0f, 0.5f,   0.0f, 0.0f, 0.7f,
         0.5f, 0.0f, 0.0f,   0.7f, 0.7f, 0.7f
    };

    unsigned int ind1[] = {
        0, 1, 3, // first triangle
        1, 2, 3  // second triangle
    };

    float verta[]
    {
        0.0f, 0.0f, 0.0f, 
        0.0f, 0.7f, 0.0f, 
        0.0f, 0.7f, 0.7f, 
        0.0f, 0.0f, 0.7f, 
        0.7f, 0.0f, 0.0f, 
        0.7f, 0.7f, 0.0f, 
        0.7f, 0.7f, 0.7f, 
        0.7f, 0.0f, 0.7f
    };

    
    unsigned int indos[] = {
        0, 1, 3,
        3, 2, 1,
        3, 2, 7,
        7, 6, 2,
        7, 6, 4,
        4, 5, 6,
        0, 1, 4,
        4, 5, 1,
        0, 3, 4,
        4, 7, 3,
        1, 2, 5,
        5, 6, 2
    };

    /*
        
        view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));

        glm::mat4 trans = glm::mat4(1.0f);
        trans = glm::scale(trans, glm::vec3(0.7f, 0.7f, 0.7f));
        
        trans = glm::translate(trans, glm::vec3(0.4f, -0.4f, 0.0f));

        unsigned int transformLoc = glGe    tUniformLocation(theShader.ID, "transform");
        glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));

        trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(1.0, 0.0, 1.0));
        unsigned int transform = glGetUniformLocation(theShader.ID, "transform");
        glUniformMatrix4fv(transform, 1, GL_FALSE, glm::value_ptr(trans));
        */

        /*
        const float radius = 10.0f;
        float camX = cos(glfwGetTime()) * radius;
        float camZ = sin(glfwGetTime()) * radius;
        view = glm::lookAt(glm::vec3(camX, 0.0f, camZ), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0));*/

        float vert[] = {
        // positions          // colors           // texture coords
         0.5f,  0.5f, 0.0f,   0.7f, 0.0f, 0.0f,   2.0f, 2.0f,   // top right
         0.5f, -0.5f, 0.0f,   0.0f, 0.7f, 0.0f,   2.0f, 0.0f,   // bottom right
        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 0.7f,   0.0f, 0.0f,   // bottom left
        -0.5f,  0.5f, 0.0f,   0.7f, 0.7f, 0.0f,   0.0f, 2.0f    // top left 
    };
   
   * vec4(aColor, 1.0)
   
   glm::vec3 cubePositions[] = {
        glm::vec3(0.0f,  0.0f,  0.0f),
        glm::vec3(2.0f,  5.0f, -15.0f),
        glm::vec3(-1.5f, -2.2f, -2.5f),
        glm::vec3(-3.8f, -2.0f, -12.3f),
        glm::vec3(2.4f, -0.4f, -3.5f),
        glm::vec3(-1.7f,  3.0f, -7.5f),
        glm::vec3(1.3f, -2.0f, -2.5f),
        glm::vec3(1.5f,  2.0f, -2.5f),
        glm::vec3(1.5f,  0.2f, -1.5f),
        glm::vec3(-1.3f,  1.0f, -1.5f)
};

 /*
        glDrawArrays(GL_TRIANGLES, 0, 6);

        for (unsigned int abba = 0; abba < 10; abba++)
        {
            glm::mat4 model = glm::mat4(1.0f);
            float angle = 20.0f * abba;

            model = glm::translate(model, cubePositions[abba]);
            model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(1.0f, 0.3f, 0.5f));
            theShader.setUniformMat4("model", model);

            glBindVertexArray(VAO);

            glDrawArrays(GL_TRIANGLES, 0, 36);
        }
        glDrawArrays(GL_TRIANGLES, 0, 36);

        */

        /*
        float timeValue = glfwGetTime();
        float greenValue = (sin(timeValue) / 2.0f) + 0.5f;
        int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");
        glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 0.7f);

        */
        
unsigned int indi2[]
{
    0, 1, 2
};

    /*
    theShader.use();
    theShader.setInt("texture1", 0);
    theShader.setInt("texture2", 1);
    */

    float vert3d2[]
{
    0.0f, 0.0f, 0.0f, 0.1f, 0.6f, 0.8f, 1.0f,
    2.0f, 0.0f, 0.0f, 0.1f, 0.6f, 0.8f, 1.0f,
    2.0f, 0.0f, 2.0f, 0.1f, 0.6f, 0.8f, 1.0f,
    0.0f, 0.0f, 2.0f, 0.1f, 0.6f, 0.8f, 1.0f,

    0.0f, 2.0f, 0.0f, 0.1f, 0.6f, 0.8f, 1.0f,
    2.0f, 2.0f, 0.0f, 0.1f, 0.6f, 0.8f, 1.0f,
    2.0f, 2.0f, 2.0f, 0.1f, 0.6f, 0.8f, 1.0f,
    0.0f, 2.0f, 2.0f, 0.1f, 0.6f, 0.8f, 1.0f
};

 /*
        glm::vec3 lightColor;
        lightColor.x = sin(glfwGetTime() * 2.0f);
        lightColor.y = sin(glfwGetTime() * 0.7f);
        lightColor.z = sin(glfwGetTime() * 1.3f);
        
        glm::vec3 diffuseColor = lightColor * glm::vec3(0.5f);
        glm::vec3 ambientColor = diffuseColor * glm::vec3(0.2f);

        theShader.setUniform3f("light.ambient", ambientColor);
        theShader.setUniform3f("light.diffuse", diffuseColor);

        */


         /*
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vert3d), vert3d, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 8, (void*) 0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 8, (void*) (3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 8, (void*) (6 * sizeof(float)));
    glEnableVertexAttribArray(2);
    
    */
    /*----------------------------------------------------------------------------------------------------------*/


std::vector<std::string> faces
{
    {"Resources/backgrounds/right.jpg",
        "Resources/backgrounds/left.jpg",
        "Resources/backgrounds/top.jpg",
        "Resources/backgrounds/bottom.jpg",
        "Resources/backgrounds/front.jpg",
        "Resources/backgrounds/back.jpg"}
};     


float skyboxVertices[] = {
    // positions          
    -1.0f,  1.0f, -1.0f,
    -1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,

    -1.0f, -1.0f,  1.0f,
    -1.0f, -1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f,  1.0f,
    -1.0f, -1.0f,  1.0f,

     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,

    -1.0f, -1.0f,  1.0f,
    -1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f, -1.0f,  1.0f,
    -1.0f, -1.0f,  1.0f,

    -1.0f,  1.0f, -1.0f,
     1.0f,  1.0f, -1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
    -1.0f,  1.0f,  1.0f,
    -1.0f,  1.0f, -1.0f,

    -1.0f, -1.0f, -1.0f,
    -1.0f, -1.0f,  1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
    -1.0f, -1.0f,  1.0f,
     1.0f, -1.0f,  1.0f
};

unsigned int uniform1 = glGetUniformBlockIndex(modelShader.ID, "Matrices");
    unsigned int uniform2 = glGetUniformBlockIndex(lampLight.ID, "Matrices");
    unsigned int uniform3 = glGetUniformBlockIndex(normalShader.ID, "Matrices");

    glUniformBlockBinding(modelShader.ID, uniform1, 0);
    glUniformBlockBinding(lampLight.ID, uniform2, 0);
    glUniformBlockBinding(normalShader.ID, uniform3, 0);

    unsigned int uboMatrix;
    glGenBuffers(1, &uboMatrix);

    glBindBuffer(GL_UNIFORM_BUFFER, uboMatrix);
    glBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW);
    glBindBuffer(GL_UNIFORM_BUFFER, 0);
    glBindBufferRange(GL_UNIFORM_BUFFER, 0, uboMatrix, 0, (sizeof(glm::mat4)) * 2);
    glBindBuffer(GL_UNIFORM_BUFFER, 0); 